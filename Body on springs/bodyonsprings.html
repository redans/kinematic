<!DOCTYPE html>
<html>

<head>
    <title>kinematic body</title>
    <link rel="icon"
        href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMjU2IgogICBoZWlnaHQ9IjI1NiIKICAgdmlld0JveD0iMCAwIDI1NiAyNTYiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9IlNWR1Jvb3QiCiAgIHNvZGlwb2RpOmRvY25hbWU9Imljb24uc3ZnIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIxLjIuMiAoYjBhODQ4NiwgMjAyMi0xMi0wMSkiCiAgIGlua3NjYXBlOmRhdGFsb3NzPSJ0cnVlIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3ODkiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjMDAwMDAwIgogICAgIGJvcmRlcm9wYWNpdHk9IjAuMjUiCiAgICAgaW5rc2NhcGU6c2hvd3BhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iI2QxZDFkMSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6em9vbT0iMi42ODAyODg0IgogICAgIGlua3NjYXBlOmN4PSIxNDcuMTg1NjUiCiAgICAgaW5rc2NhcGU6Y3k9IjEyMy42ODA3MiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE2ODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iOTMzIgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNSIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQ5NSIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8ZGVmcwogICAgIGlkPSJkZWZzODQiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJvcGFjaXR5OjAuOTtmaWxsOiNmZjk5NTU7c3Ryb2tlOiNmZjk5NTU7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgaWQ9InJlY3QyMTc4IgogICAgICAgd2lkdGg9IjI1NSIKICAgICAgIGhlaWdodD0iMjU1IgogICAgICAgeD0iMCIKICAgICAgIHk9IjAiCiAgICAgICByeT0iMjUiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMCIKICAgICAgIGQ9Ik0gMTI0Ljk0ODExLDExOS45MjE0NiAyMTUuMDY4NzIsMjQuNzc0MTk0IgogICAgICAgaWQ9InBhdGg5MzYiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGQ9Ik0gMjAwLDQ1IDIyNSwyMCIKICAgICAgIGlkPSJwYXRoOTM4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBkPSJNIDIwMC40MjQ2OCw0Mi45MjQ2OCAyMTAsODAiCiAgICAgICBpZD0icGF0aDkzOC0wIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO3N0cm9rZTojMDAwMDAwIgogICAgICAgZD0iTSAyMDIuMDc1MzIsNDQuNTc1MzIgMTY1LDM1IgogICAgICAgaWQ9InBhdGg5MzgtMC05IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBpZD0icGF0aDEwOTQiCiAgICAgICBjeD0iNTAiCiAgICAgICBjeT0iMTE1IgogICAgICAgcj0iMzAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDBmZjtzdHJva2Utd2lkdGg6MTY7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgZD0ibSA1MCwxMTUgaCA4NSBsIDY1LC03MCIKICAgICAgIGlkPSJwYXRoMTE5NiIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwZmY7c3Ryb2tlLXdpZHRoOjE4LjQ3NTI7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgZD0iTSAxMzUsMTE1IFYgMjM1IgogICAgICAgaWQ9InBhdGgxMTk4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBkPSJNIDE2NSwzNSAyMjUsMjAgMjEwLDgwIFoiCiAgICAgICBpZD0icGF0aDIxMjAiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBpZD0icGF0aDg4MCIKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBjeD0iMTI0Ljk0ODExIgogICAgICAgY3k9IjExOS45MjE0NiIKICAgICAgIHI9IjAuMTgwNzU0NDUiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO2ZpbGw6I2ZmMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGlkPSJwYXRoMTA5NiIKICAgICAgIGN4PSIyMDAiCiAgICAgICBjeT0iNDUuNSIKICAgICAgIHI9IjEyLjUiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO2ZpbGw6I2ZmMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGlkPSJwYXRoMTA5Ni0zLTIiCiAgICAgICBjeD0iNTAiCiAgICAgICBjeT0iMTE0LjUiCiAgICAgICByPSIxMi41IiAvPgogICAgPGNpcmNsZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTtmaWxsOiNmZjAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBpZD0icGF0aDEwOTYtMyIKICAgICAgIGN4PSIxMzUuNSIKICAgICAgIGN5PSIyMDUiCiAgICAgICByPSIxMi41IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBkPSJtIDk1LDE4MSBoIDc1IHYgNTAgSCA5NSBaIgogICAgICAgaWQ9InBhdGg1MTkyIiAvPgogIDwvZz4KPC9zdmc+Cg=="
        type="image/svg+xml">
    <link rel="shortcut icon"
        href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMjU2IgogICBoZWlnaHQ9IjI1NiIKICAgdmlld0JveD0iMCAwIDI1NiAyNTYiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9IlNWR1Jvb3QiCiAgIHNvZGlwb2RpOmRvY25hbWU9Imljb24uc3ZnIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIxLjIuMiAoYjBhODQ4NiwgMjAyMi0xMi0wMSkiCiAgIGlua3NjYXBlOmRhdGFsb3NzPSJ0cnVlIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3ODkiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjMDAwMDAwIgogICAgIGJvcmRlcm9wYWNpdHk9IjAuMjUiCiAgICAgaW5rc2NhcGU6c2hvd3BhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iI2QxZDFkMSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6em9vbT0iMi42ODAyODg0IgogICAgIGlua3NjYXBlOmN4PSIxNDcuMTg1NjUiCiAgICAgaW5rc2NhcGU6Y3k9IjEyMy42ODA3MiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE2ODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iOTMzIgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNSIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQ5NSIgLz4KICA8L3NvZGlwb2RpOm5hbWVkdmlldz4KICA8ZGVmcwogICAgIGlkPSJkZWZzODQiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJvcGFjaXR5OjAuOTtmaWxsOiNmZjk5NTU7c3Ryb2tlOiNmZjk5NTU7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgaWQ9InJlY3QyMTc4IgogICAgICAgd2lkdGg9IjI1NSIKICAgICAgIGhlaWdodD0iMjU1IgogICAgICAgeD0iMCIKICAgICAgIHk9IjAiCiAgICAgICByeT0iMjUiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMCIKICAgICAgIGQ9Ik0gMTI0Ljk0ODExLDExOS45MjE0NiAyMTUuMDY4NzIsMjQuNzc0MTk0IgogICAgICAgaWQ9InBhdGg5MzYiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGQ9Ik0gMjAwLDQ1IDIyNSwyMCIKICAgICAgIGlkPSJwYXRoOTM4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBkPSJNIDIwMC40MjQ2OCw0Mi45MjQ2OCAyMTAsODAiCiAgICAgICBpZD0icGF0aDkzOC0wIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO3N0cm9rZTojMDAwMDAwIgogICAgICAgZD0iTSAyMDIuMDc1MzIsNDQuNTc1MzIgMTY1LDM1IgogICAgICAgaWQ9InBhdGg5MzgtMC05IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxjaXJjbGUKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBpZD0icGF0aDEwOTQiCiAgICAgICBjeD0iNTAiCiAgICAgICBjeT0iMTE1IgogICAgICAgcj0iMzAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDBmZjtzdHJva2Utd2lkdGg6MTY7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgZD0ibSA1MCwxMTUgaCA4NSBsIDY1LC03MCIKICAgICAgIGlkPSJwYXRoMTE5NiIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwZmY7c3Ryb2tlLXdpZHRoOjE4LjQ3NTI7c3Ryb2tlLWRhc2hhcnJheTpub25lIgogICAgICAgZD0iTSAxMzUsMTE1IFYgMjM1IgogICAgICAgaWQ9InBhdGgxMTk4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBkPSJNIDE2NSwzNSAyMjUsMjAgMjEwLDgwIFoiCiAgICAgICBpZD0icGF0aDIxMjAiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBpZD0icGF0aDg4MCIKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBjeD0iMTI0Ljk0ODExIgogICAgICAgY3k9IjExOS45MjE0NiIKICAgICAgIHI9IjAuMTgwNzU0NDUiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO2ZpbGw6I2ZmMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGlkPSJwYXRoMTA5NiIKICAgICAgIGN4PSIyMDAiCiAgICAgICBjeT0iNDUuNSIKICAgICAgIHI9IjEyLjUiIC8+CiAgICA8Y2lyY2xlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO2ZpbGw6I2ZmMDAwMDtzdHJva2U6IzAwMDAwMCIKICAgICAgIGlkPSJwYXRoMTA5Ni0zLTIiCiAgICAgICBjeD0iNTAiCiAgICAgICBjeT0iMTE0LjUiCiAgICAgICByPSIxMi41IiAvPgogICAgPGNpcmNsZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTtmaWxsOiNmZjAwMDA7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICBpZD0icGF0aDEwOTYtMyIKICAgICAgIGN4PSIxMzUuNSIKICAgICAgIGN5PSIyMDUiCiAgICAgICByPSIxMi41IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxNjtzdHJva2UtZGFzaGFycmF5Om5vbmUiCiAgICAgICBkPSJtIDk1LDE4MSBoIDc1IHYgNTAgSCA5NSBaIgogICAgICAgaWQ9InBhdGg1MTkyIiAvPgogIDwvZz4KPC9zdmc+Cg=="
        type="image/svg+xml">


    <style>
        body {
            font-family: Arial, sans-serif;
        }

        header {
            background-color: #061e96;
            color: #fff;
            padding: 10px;
            text-align: center;
        }



        table {
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;

        }


        th,
        td {
            border: 1px solid rgba(47, 125, 241, 0.161);
            padding: 10px;
            text-align: left;
        }

        .holdleft {
            text-align: left;
            column-span: 2;
        }


        .centered {
            text-align: center;
            column-span: 4;
        }

        .centered textarea {
            text-align: center;
            margin: 0 auto;
            display: block;
        }

        .holdright {
            text-align: right;
            column-span: 2;
        }

        nav {
            background-color: #ccc;
            padding: 10px;
        }


        .resultbar {
            background-color: #2944b0;
            color: #f5ecec;
            padding: 10px;
            text-align: center;
        }

        footer {
            background-color: #747474;
            color: #fff;
            padding: 10px;
            text-align: center;
        }

        main {
            margin: 0 auto;
            max-width: 1200px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(160, 130, 130, 0.3);
        }

        td {
            white-space: normal;
        }
    </style>
</head>



<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>


<script src="https://cdn.plot.ly/plotly-2.20.0.min.js" charset="utf-8"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/newton-raphson-method@1.0.2/index.min.js"></script> -->

<!-- <script src='bodyLib.js'></script> -->



<header>
    <h1>Impact of Disturbance Forces on Kinematic Body</h1>
</header>

<footer style="text-align: left; background-color: rgb(159, 157, 157);">
    DRAFT <br>
    version 01<br> 09-06-2023

</footer>
<main>


    <div>
<!-- User interface-->
        <table>


            <tr>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
            </tr>
            <tr>

                <td class="hold left" colspan="5">
                    <h2>Calculation Tool Functionality</h2>
                    <p>This tool provides a comprehensive analysis of a rigid body subjected to forces. The body must be
                        constrained by 6 degrees of freedom, with each degree of freedom having stiffness in its normal
                        direction. The tool visualizes the constraints in the 3D plot. The required inputs for the tool are as follows:</p>
                    <ol>
                        <li>Interface normals in column format [nx, ny, nz] (6x) with row numbers corresponding to
                            n1...n6.</li>
                        <li>Interface points in column format [x, y, z] (6x) with row numbers corresponding to p1...p6.
                        </li>
                        <li>Stiffness values for the interfaces in the normal directions (6x) corresponding to n1...n6.
                        </li>
                        <li>Closing forces in column format [Fx, Fy, Fz]. The number of force entries (rows) is
                            flexible.</li>
                        <li>Closing force locations in column format [x, y, z]. The number of locations should
                            correspond to the number of forces.</li>
                    </ol>
                    <p>Outputs are forces on the interfaces, deformation of those interfaces and the body deformation defined in World Coordinate System (WCS).</p>
                        All calculations are performed in the unit system, preferably use meters to avoid misinterpretation. The interface normals
                        are automatically normalized in the background, eliminating the need for user intervention.
                        </ol>


                    </p>
                </td>

                <td class="centered" colspan="5">

                    <!--  <canvas id="plotConfig"></canvas> -->
                    <table id="plotConfig"></table>


                </td>
            </tr>
            <tr>
                <td class="centered" colspan="5"><i>Mind that error handling is very limited. No results is probably caused by wrong input. Check the body is actually constrained and make sure the closing force has connection points to the body. Also make sure all input are numerical values.</i></td>


                <td class="centered" colspan="5">
                    <sub>
                        <span style="color: red;">Red line</span> representing interface normals towards the 
                        <span style="color: blue;">blue dot</span> indicating interface points.
                        <span style="color: green;">Green line</span> representing a "pulling" force
                        to the <span style="color: green;">green dot</span> indicating the connection point. No arrows because plotly.js doesn't provide those.
                    </sub>
                </td>
            </tr>
            <tr>
                <td colspan="10">
                    <div class="resultbar">INPUTS and drawing option</div>
                </td>
            </tr>
            <td class="centered" colspan="3">
                <button type="submit" onclick="drawVectors()"
                    style="background-color: rgb(6, 60, 11); color: white;"> PRESS --> draw new input vectors and re-calculate</button>
            </td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>
            <td><!-- empty cell --></td>


            <tr>
                <td class="centered" colspan="5">
                    <label for="matrix-input1">normals of interfaces [nx ny nz]</label>
                </td>

                <td class="centered" colspan="5">
                    <label for="matrix-input2">interfaces points [px py pz]</label>
                </td>
            </tr>

            <tr>
                <td class="centered" colspan="5">
                    <textarea id="matrix-input1" name="textarea1" rows="6" cols="70"></textarea>
                </td>

                <td class="centered" colspan="5">
                    <textarea id="matrix-input2" name="textarea2" rows="6" cols="70"></textarea>
                </td>
            </tr>

            <td class="centered" colspan="2">
                <br>
                Interface stiffness <br> <sub>in normal direction</sub>
            </td>
            <td class="centered" colspan="4">
                <br>
                closing force [Fx Fy Fz]
            </td>

            <td class="centered" colspan="4">
                <br>
                closing force location [x y z]
            </td>

            </tr>

            <tr>
                <td class="centered" colspan="2">
                    <textarea id="matrix-input5" name="textarea5" rows="6" cols="20"></textarea>
                </td>
                <td class="centered" colspan="4">
                    <textarea id="matrix-input3" name="textarea3" rows="6" cols="55"></textarea>
                </td>

                <td class="centered" colspan="4">
                    <textarea id="matrix-input4" name="textarea4" rows="6" cols="55"></textarea>
                </td>
            </tr>

            </tr>

            <tr>
                <td colspan="10">
                    <div class="resultbar">CALCULATION RESULTS</div>
                </td>
            </tr>


            </tr>

            <tr>
                <td><!-- empty cell --></td>
                <td class="centered" colspan="2">
                    <table id="ForcesOnIf"></table>
                </td>
                <td><!-- empty cell --></td>
                <td class="centered" colspan="2">
                    <table id="DefOffIf"></table>
                </td>
                <td><!-- empty cell --></td>
                <td class="centered" colspan="2">
                    <table id="DefOffWCS"></table>
                </td>
                <td><!-- empty cell --></td>

            </tr>
            <tr>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
                <td><!-- empty cell --></td>
            </tr>




        </table>
        <script>

{//bodyLib scripts
    function motionAinv(n, p) {

const a = [[n[0][0], n[0][1], n[0][2], n[0][2] * p[0][1] - n[0][1] * p[0][2], n[0][0] * p[0][2] - n[0][2] * p[0][0], n[0][1] * p[0][0] - n[0][0] * p[0][1]],
[n[1][0], n[1][1], n[1][2], n[1][2] * p[1][1] - n[1][1] * p[1][2], n[1][0] * p[1][2] - n[1][2] * p[1][0], n[1][1] * p[1][0] - n[1][0] * p[1][1]],
[n[2][0], n[2][1], n[2][2], n[2][2] * p[2][1] - n[2][1] * p[2][2], n[2][0] * p[2][2] - n[2][2] * p[2][0], n[2][1] * p[2][0] - n[2][0] * p[2][1]],
[n[3][0], n[3][1], n[3][2], n[3][2] * p[3][1] - n[3][1] * p[3][2], n[3][0] * p[3][2] - n[3][2] * p[3][0], n[3][1] * p[3][0] - n[3][0] * p[3][1]],
[n[4][0], n[4][1], n[4][2], n[4][2] * p[4][1] - n[4][1] * p[4][2], n[4][0] * p[4][2] - n[4][2] * p[4][0], n[4][1] * p[4][0] - n[4][0] * p[4][1]],
[n[5][0], n[5][1], n[5][2], n[5][2] * p[5][1] - n[5][1] * p[5][2], n[5][0] * p[5][2] - n[5][2] * p[5][0], n[5][1] * p[5][0] - n[5][0] * p[5][1]],
];
return math.inv(a);
}

function motionB(n, scale) {
let b = new Array(6); // create an array of length 6
for (let i = 0; i < 6; i++) {
    b[i] = new Array(6).fill(0); // initialize each element of b to an array of length 6 filled with 0s
}

for (let ii = 0; ii < 6; ii++) {
    b[ii][ii] = -scale * math.pow(n[ii][0], 2) - scale * math.pow(n[ii][1], 2) - scale * math.pow(n[ii][2], 2);
}

return b;
}

function Rt(Rx, Ry, Rz) {
return [
    [1, -Rz, Ry],
    [Rz, 1, -Rx],
    [-Ry, Rx, 1]
];
}

function normr(valueIn) {
const deform = [...valueIn]//.map(row => [...row]); // Create a copy of the array
for (let i = 0; i < deform.length; i++) {
    const row = deform[i];
    const norm = math.norm(row, 2); // Compute the L2 norm of the row
    if (norm !== 0) { // Check if the norm is not zero
        deform[i] = row.map(x => x / norm); // Divide each element of the row by its norm
    } else {
        deform[i] = row; // If the norm is zero, leave the row unchanged
    }
}
return deform;
}


function normrP(deform) {

for (let i = 0; i < deform.length; i++) {
    const slice = deform[i];

    for (let j = 0; j < slice.length; j++) {
        const row = slice[j];

        const norm = math.norm(row, 2); // Compute the L2 norm of the row
        if (norm !== 0) { // Check if the norm is not zero
            slice[j] = row.map(x => x / norm); // Divide each element of the row by its norm
        } else {
            slice[j] = row; // If the norm is zero, leave the row unchanged
        }
    }
}
return deform;
}

function calculateDeformation(p, DOF) {
var deformation = [];
//console.log(p)
//console.log(DOF)
const pPrime = math.transpose(p);

for (var i = 0; i <= 5; i++) {
    const temp = math.subtract(math.transpose(p), math.add(math.multiply(Rt(DOF[3][i], DOF[4][i], DOF[5][i]), pPrime), math.transpose([[DOF[0][i], DOF[1][i], DOF[2][i]]])));
    deformation.push(math.transpose(temp.valueOf()));
}
//console.log(deformation)
return deformation;
}


function ForceA(p, F) {
const af = [[F[0][0], F[1][0], F[2][0], F[3][0], F[4][0], F[5][0]],
[F[0][1], F[1][1], F[2][1], F[3][1], F[4][1], F[5][1]],
[F[0][2], F[1][2], F[2][2], F[3][2], F[4][2], F[5][2]],
[F[0][1] * p[0][2] - F[0][2] * p[0][1], F[1][1] * p[1][2] - F[1][2] * p[1][1], F[2][1] * p[2][2] - F[2][2] * p[2][1], F[3][1] * p[3][2] - F[3][2] * p[3][1], F[4][1] * p[4][2] - F[4][2] * p[4][1], F[5][1] * p[5][2] - F[5][2] * p[5][1]],
[F[0][2] * p[0][0] - F[0][0] * p[0][2], F[1][2] * p[1][0] - F[1][0] * p[1][2], F[2][2] * p[2][0] - F[2][0] * p[2][2], F[3][2] * p[3][0] - F[3][0] * p[3][2], F[4][2] * p[4][0] - F[4][0] * p[4][2], F[5][2] * p[5][0] - F[5][0] * p[5][2]],
[F[0][0] * p[0][1] - F[0][1] * p[0][0], F[1][0] * p[1][1] - F[1][1] * p[1][0], F[2][0] * p[2][1] - F[2][1] * p[2][0], F[3][0] * p[3][1] - F[3][1] * p[3][0], F[4][0] * p[4][1] - F[4][1] * p[4][0], F[5][0] * p[5][1] - F[5][1] * p[5][0]]
];

return af;
}

function ForceB(Fc, coordFc) {
const b = [
    -Fc[0],
    -Fc[1],
    -Fc[2],
    coordFc[1] * Fc[2] - coordFc[2] * Fc[1],
    coordFc[2] * Fc[0] - coordFc[0] * Fc[2],
    coordFc[0] * Fc[2] - coordFc[1] * Fc[0]
];

return b;
}

function rowForceB(Fc, coordFc) {
const b = [0, 0, 0, 0, 0, 0];

for (let i = 0; i < Fc.length; i++) {
    const rowFc = Fc[i];
    const rowCoordFc = coordFc[i];

    const bRow = [
        -rowFc[0],
        -rowFc[1],
        -rowFc[2],
        rowCoordFc[1] * rowFc[2] - rowCoordFc[2] * rowFc[1],
        rowCoordFc[2] * rowFc[0] - rowCoordFc[0] * rowFc[2],
        rowCoordFc[0] * rowFc[1] - rowCoordFc[1] * rowFc[0]
    ];

    for (let j = 0; j < bRow.length; j++) {
        b[j] += bRow[j];
    }
}

return b;
}




function kynCalc(n, p, mu, scale, Fc, coordFc) {

const normNormals = normr(n)


//const { norm: _norm, inv, multiply, transpose, subtract, add } = require('mathjs');

const Ma = motionAinv(n, p); // calculate motion matrix a

const Mb = motionB(n, scale) // calculate motion matrix b

const WCSdeform = math.multiply(Ma, Mb); // calculate WCS deformation (motion matrices per retracted interface)

const PointDeformation = calculateDeformation(p, WCSdeform) // calculate deformation per point
//console.log(PointDeformation )
const normFw = normrP(PointDeformation); // normalized friction vectors



const F = normrP(math.add(math.multiply(normFw, mu), n)) // normalized force vectors 
//console.table('stop')
// calculate all 6 force matrices a
const CC = [];
for (var i = 0; i <= 5; i++) {
    CC.push(ForceA(p, F[i]));
}

const BB = ForceB(Fc, coordFc) // calculate force vector b

// calculate interface forces
const Finterface = [];
for (var i = 0; i <= 5; i++) {
    Finterface.push(math.multiply(math.inv(CC[i]), BB));
}

//console.table(transpose(Finterface))

return [Finterface, WCSdeform]
}


function populateTable(tableId, data, fontSize, numberFormat, rowNames, columnNames, tableHeader) {
const table = document.getElementById(tableId);
table.style.fontSize = fontSize;
table.innerHTML = ""; // Clear the table
table.style.borderCollapse = "collapse"; // Add border-collapse style
table.style.border = "2px solid black"; // Add border style

// Create table header (caption)
if (tableHeader) {
  const caption = document.createElement("caption");
  const captionText = document.createTextNode(tableHeader);
  caption.appendChild(captionText);
  caption.style.fontSize = "14px"; // Set font size
  caption.style.fontWeight = "bold"; // Apply bold style
  table.appendChild(caption);
}

// Create header row with column names
const headerRow = document.createElement("tr");
const emptyHeaderCell = document.createElement("th"); // Empty header cell for row labels
headerRow.appendChild(emptyHeaderCell);

for (let i = 0; i < columnNames.length; i++) {
  const cell = document.createElement("th");
  cell.style.border = "1px solid black"; // Add border to column name cells
  cell.appendChild(document.createTextNode(columnNames[i]));
  headerRow.appendChild(cell);
}
table.appendChild(headerRow);

// Determine the number of columns in the data
const numColumns = Array.isArray(data[0]) ? data[0].length : 1;

// Create rows for each case with row label and data values
for (let i = 0; i < rowNames.length; i++) {
  const row = document.createElement("tr");

  // Add row name as the first cell
  const rowNameCell = document.createElement("td");
  rowNameCell.style.border = "1px solid black"; // Add border to row name cell
  rowNameCell.appendChild(document.createTextNode(rowNames[i]));
  row.appendChild(rowNameCell);

  if (numColumns === 1) {
    // Single column data
    const cell = document.createElement("td");
    if (data[i] < 0) {
      cell.style.color = "red";
    }
    cell.style.border = "1px solid black"; // Add border to data cell

    // Format the number based on the specified format
    if (numberFormat === "exponential") {
      cell.appendChild(document.createTextNode(data[i].toExponential(2)));
      
    } else if (numberFormat === "fixed") {
      //cell.appendChild(document.createTextNode(data[i].toFixed(2)));
      cell.appendChild(document.createTextNode(data[i]));
    } else {
      // Default: No specific format, use the number as is
      cell.appendChild(document.createTextNode(data[i]));
    }

    row.appendChild(cell);
  } else {
    // Multiple columns data
    for (let j = 0; j < numColumns; j++) {
      const cell = document.createElement("td");
      if (data[i][j] < 0) {
        cell.style.color = "red";
      }
      cell.style.border = "1px solid black"; // Add border to data cells

      // Format the number based on the specified format
      if (numberFormat === "exponential") {
        //cell.appendChild(document.createTextNode(data[i][j].toExponential(2)));
        cell.appendChild(document.createTextNode(data[i][j]));
      } else if (numberFormat === "fixed") {
        //cell.appendChild(document.createTextNode(data[i][j].toFixed(2)));
        cell.appendChild(document.createTextNode(data[i][j]));
      } else {
        // Default: No specific format, use the number as is
        cell.appendChild(document.createTextNode(data[i][j]));
      }

      row.appendChild(cell);
    }
  }

  table.appendChild(row);
}

// Apply border styles to entire table
const cells = table.getElementsByTagName("td");
for (let i = 0; i < cells.length; i++) {
  cells[i].style.border = "1px solid black";
}
const headerCells = table.getElementsByTagName("th");
for (let i = 0; i < headerCells.length; i++) {
  headerCells[i].style.border = "1px solid black";
}
}
   
function roundArrayToDecimals(array,dig) {
return array.map(number => Number(number.toFixed(dig)));
}




function findNegativeForceMuPlus(nn, pp, Fcc, coordFcc, resolution) {


let mu = 0;
while (true) {
    // Calculate the forces and deformations for the current mu value
    const [FinterfaceF, WCSdeformF] = kynCalc(nn, pp, mu, 0.1, Fcc, coordFcc);

    // Check if any of the FinterfaceF values are negative
    if (FinterfaceF.some((row) => row.some((val) => val < 0))) {
        // Negative force found, return the current mu value
        return mu;

    }

    // Increment the mu value and continue looping
    mu += resolution;

}
}

function findNegativeForceMuMin(nn, pp, Fcc, coordFcc, resolution) {

let mu = 0;
while (true) {
    // Calculate the forces and deformations for the current mu value
    const [FinterfaceF, WCSdeformF] = kynCalc(nn, pp, mu, 0.1, Fcc, coordFcc);

    // Check if any of the FinterfaceF values are negative
    if (FinterfaceF.some((row) => row.some((val) => val < 0))) {
        // Negative force found, return the current mu value
        return mu;

    }

    // Increment the mu value and continue looping
    mu -= resolution;
}
}








function findLargestNumbers(array) {
const largestPositiveNumbers = [];
const largestNegativeNumbers = [];

for (let i = 0; i < array.length; i++) {
    let maxPositive = -Infinity;
    let maxNegative = -Infinity;

    for (let j = 0; j < array[i].length; j++) {
        const value = array[i][j];

        if (value > 0 && value > maxPositive) {
            maxPositive = value;
        } else if (value < 0 && value > maxNegative) {
            maxNegative = value;
        }
    }

    largestPositiveNumbers.push(maxPositive);
    largestNegativeNumbers.push(maxNegative);
}

return [largestPositiveNumbers, largestNegativeNumbers];
}

function findMinMaxNumbers(array) {
const smallestNumbers = [];
const largestNumbers = [];
for (let i = 0; i < array.length; i++) {
    let smallest = Infinity;
    let largest = -Infinity;

    for (let j = 0; j < array[i].length; j++) {
        const value = array[i][j];

        if (value < smallest) {
            smallest = value;
        }

        if (value > largest) {
            largest = value;
        }
    }

    smallestNumbers.push(smallest);
    largestNumbers.push(largest);
}

return [smallestNumbers, largestNumbers];

}


function flipLR(matrix) {
const flippedMatrix = [];

for (let i = 0; i < matrix.length; i++) {
    flippedMatrix.push(matrix[i].reverse());
}

return flippedMatrix;
}


function plotGraph(x, y, targetElementId, title, xAxisName, yAxisName, traceNames) {
// Create an array to hold the data traces
var data = [];

// Iterate over the y array to create individual traces
for (var i = 0; i < y.length; i++) {
    var trace = {
        x: x,
        y: y[i],
        mode: 'lines',
        name: traceNames[i] || 'Trace ' + (i + 1)
    };
    data.push(trace);
}

// Set up the layout options
var layout = {
    title: title || 'Plot',
    xaxis: { title: xAxisName || 'X' },
    yaxis: { title: yAxisName || 'Y' }
};

// Create the plot
Plotly.newPlot(targetElementId, data, layout);
}




function linspace(start, end, numSteps) {
const stepSize = (end - start) / (numSteps - 1);
const values = [];

for (let i = 0; i < numSteps; i++) {
    const value = start + stepSize * i;
    values.push(value);
}

return values;
}

function diff(data) {
const result = [];

for (let i = 0; i < data.length; i++) {
    const line = data[i];
    const diffLine = [];

    for (let j = 1; j < line.length; j++) {
        const diffValue = line[j] - line[j - 1];
        diffLine.push(diffValue);
    }

    result.push(diffLine);
}

return result;
}


function cTransL(X, Y, Z, thx, thy, thz, cX, cY, cZ) {
const Tci = [
    [1, 0, 0, -cX],
    [0, 1, 0, -cY],
    [0, 0, 1, -cZ],
    [0, 0, 0, 1]
];

const Tco = [
    [1, 0, 0, cX],
    [0, 1, 0, cY],
    [0, 0, 1, cZ],
    [0, 0, 0, 1]
];

const Rx = [
    [1, 0, 0, 0],
    [0, math.cos(thx), -math.sin(thx), 0],
    [0, math.sin(thx), math.cos(thx), 0],
    [0, 0, 0, 1]
];

const Ry = [
    [math.cos(thy), 0, math.sin(thy), 0],
    [0, 1, 0, 0],
    [-math.sin(thy), 0, math.cos(thy), 0],
    [0, 0, 0, 1]
];

const Rz = [
    [math.cos(thz), -math.sin(thz), 0, 0],
    [math.sin(thz), math.cos(thz), 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1]
];

const Txyz = [
    [1, 0, 0, X],
    [0, 1, 0, Y],
    [0, 0, 1, Z],
    [0, 0, 0, 1]
];

const Tout = math.multiply(math.multiply(math.multiply(math.multiply(math.multiply(Txyz, Tco), Rz), Ry), Rx), Tci);
return Tout;
}

function concatenateMatrices(matrix1, matrix2) {
if (matrix1.length !== matrix2.length) {
    throw new Error("Matrix dimensions do not match.");
}

const result = [];
const rows = matrix1.length;

for (let i = 0; i < rows; i++) {
    result.push([...matrix1[i], ...matrix2[i]]);
}

return result;
}


function findMaxPerRow(array) {
const maxColumns = [];

for (let row = 0; row < array.length; row++) {
    let max = array[row][0];
    let maxCol = 0;

    for (let col = 1; col < array[row].length; col++) {
        if (array[row][col] > max) {
            max = array[row][col];
            maxCol = col;
        }
    }

    maxColumns.push(maxCol);
}

return maxColumns;
}

function perturbFc(nn, pp, Fcc, coordFcc, perturbationRange, xn, resolution) {
const mumaxvaluePlusValues = [];

for (let i = 0; i < Fcc.length; i++) {
    const perturbedFcc = [...Fcc];
    const columnValues = [];

    const perturbationStart = Fcc[i] - perturbationRange;
    const perturbationEnd = Fcc[i] + perturbationRange;
    const perturbationStep = (perturbationEnd - perturbationStart) / xn;

    for (let j = 0; j <= xn; j++) {
        const perturbationValue = perturbationStart + j * perturbationStep;
        perturbedFcc[i] = perturbationValue;

        const mumaxvaluePlus = findNegativeForceMuPlus(nn, pp, perturbedFcc, coordFcc, resolution);
        columnValues.push(mumaxvaluePlus);
    }

    mumaxvaluePlusValues.push(columnValues);
}

return mumaxvaluePlusValues;
}

function perturbCoordFc(nn, pp, Fcc, coordFcc, perturbationRange, xn, resolution) {
const mumaxvaluePlusValues = [];

for (let i = 0; i < coordFcc.length; i++) {
    const perturbedCoordFcc = [...coordFcc];
    const columnValues = [];

    const perturbationStart = coordFcc[i] - perturbationRange;
    const perturbationEnd = coordFcc[i] + perturbationRange;
    const perturbationStep = (perturbationEnd - perturbationStart) / xn;

    for (let j = 0; j <= xn; j++) {
        const perturbationValue = perturbationStart + j * perturbationStep;
        perturbedCoordFcc[i] = perturbationValue;

        const mumaxvaluePlus = findNegativeForceMuPlus(nn, pp, Fcc, perturbedCoordFcc, resolution);
        columnValues.push(mumaxvaluePlus);
    }

    mumaxvaluePlusValues.push(columnValues);
}

return mumaxvaluePlusValues;
}

function calcNewSetpoint(start_value, new_value, new_setpoint) {
const CoordX = start_value[0] + new_value[new_setpoint[0]];
const CoordY = start_value[1] + new_value[new_setpoint[1]];
const CoordZ = start_value[2] + new_value[new_setpoint[2]];

const coordNew = [CoordX, CoordY, CoordZ];
const formattedCoordNew = coordNew.map((element) => Number(element.toFixed(3)));

return [formattedCoordNew[0], formattedCoordNew[1], formattedCoordNew[2]];
}

function calculateBoundingBoxSize(coordinates) {
let minX = coordinates[0][0];
let maxX = coordinates[0][0];
let minY = coordinates[0][1];
let maxY = coordinates[0][1];
let minZ = coordinates[0][2];
let maxZ = coordinates[0][2];

for (let i = 1; i < coordinates.length; i++) {
    const point = coordinates[i];
    const x = point[0];
    const y = point[1];
    const z = point[2];

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
    minZ = Math.min(minZ, z);
    maxZ = Math.max(maxZ, z);
}

const sizeX = maxX - minX;
const sizeY = maxY - minY;
const sizeZ = maxZ - minZ;
const maxDimension = Math.max(sizeX, sizeY, sizeZ);

return {
    sizeX,
    sizeY,
    sizeZ,
    maxDimension
};
}

function create3DPlot(normals, points, forces, forceCoordinates) {
const coordinatesTrace = {
    x: [],
    y: [],
    z: [],
    mode: 'markers',
    marker: {
        size: 5,
        color: 'blue'
    },
    type: 'scatter3d',
    name: 'Points'
};

const vectorTraces = []; // Array to hold the vector traces

for (let i = 0; i < points.length; i++) {
    const [x, y, z] = points[i];
    coordinatesTrace.x.push(x);
    coordinatesTrace.y.push(y);
    coordinatesTrace.z.push(z);

    const [u, v, w] = normals[i];
    const startPoint = [x - u, y - v, z - w]; // Starting point of the vector

    const vectorTrace = {
        x: [startPoint[0], x],
        y: [startPoint[1], y],
        z: [startPoint[2], z],
        mode: 'lines',
        line: {
            color: 'red',
            width: 3
        },
        type: 'scatter3d',
        name: `N ${i + 1}`
    };

    vectorTraces.push(vectorTrace);
}

const forceTraces = []; // Array to hold the force traces

for (let i = 0; i < forces.length; i++) {
    const [forceX, forceY, forceZ] = forces[i];

    const [forceCoordX, forceCoordY, forceCoordZ] = forceCoordinates[i];

    const forceTrace = {
        x: [forceCoordX, forceCoordX + forceX],
        y: [forceCoordY, forceCoordY + forceY],
        z: [forceCoordZ, forceCoordZ + forceZ],
        mode: 'lines',
        line: {
            color: 'green',
            width: 3
        },
        type: 'scatter3d',
        name: `F ${i + 1}`
    };

    forceTraces.push(forceTrace);
}
const forceConnectionTrace = {
    x: forceCoordinates.map(coord => coord[0]),
    y: forceCoordinates.map(coord => coord[1]),
    z: forceCoordinates.map(coord => coord[2]),
    mode: 'markers',
    marker: {
        size: 5,
        color: 'green'
    },
    type: 'scatter3d',
    name: 'Force Connection'
};
const data = [coordinatesTrace, ...vectorTraces, ...forceTraces, forceConnectionTrace]; // Include coordinate traces, vector traces, and force traces

const layout = {
    scene: {
        xaxis: {
            scaleanchor: 'y',
            scaleratio: 1
        },
        yaxis: {
            scaleanchor: 'z',
            scaleratio: 1
        },
        zaxis: {
            scaleanchor: 'x',
            scaleratio: 1
        },
        annotations: [{
            x: forces[0][0],
            y: forces[0][1],
            z: forces[0][2],
            showarrow: true,
            arrowhead: 10,
            ax: 0,
            ay: 0,
            az: -40,
        }]
    },


    showlegend: false

};

Plotly.newPlot('plotConfig', data, layout);
}


{
function dotMult(array1, array2) {
    console.log(array1,array2)
    if (array1.length !== array2.length) {
      throw new Error("Arrays must have the same length");
    }
  
    const result = [];
  
    for (let i = 0; i < array1.length; i++) {
      result.push(array1[i] * array2[i]);
    }
  
    return result;
  }
}

{
function reciprocalArray(array) {
    const result = [];
  
    for (let i = 0; i < array.length; i++) {
      const reciprocal = 1 / array[i];
      result.push(reciprocal);
    }
  
    return result;
  }
}

{
function combineArrays(...arrays) {
    const combinedArray = [];
  
    for (let i = 0; i < arrays[0].length; i++) {
      const row = arrays.map(array => array[i]);
      combinedArray.push(row);
    }
  
    return combinedArray;
  }
}
}


            let predefinedNormals = [];
            let predefinedPoints = [];
            let predefinedForce = [];
            let predefinedCoord = [];
            let predefinedStiff = [];
            const textareaNormals = document.getElementById("matrix-input1");
            const textareaPoints = document.getElementById("matrix-input2");
            const textareaForce = document.getElementById("matrix-input3");
            const textareaCoord = document.getElementById("matrix-input4");
            const textareaStiff = document.getElementById("matrix-input5");



            predefinedNormals = [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1],
                [0, 1, 0],
                [0, 0, 1],
                [0, 0, 1]
            ];


            predefinedPoints = [
                [1, 0, 0],
                [1, 0, 0],
                [1, 0, 0],
                [4, 0, 0],
                [4, 0, 0],
                [3, 2, 0]
            ];

            predefinedForce = [
                [-100, 40, 0],
                [70, 0, 30]

            ];

            predefinedStiff = [
                [5e6],
                [5e6],
                [5e6],
                [5e6],
                [5e6],
                [5e6]
            ];

            predefinedCoord = [
                [1, 0, 1],
                [3, 1, 1]

            ];

            // pre-Populate tables
            textareaNormals.value = predefinedNormals.map(row => row.join("\t")).join("\n");
            textareaPoints.value = predefinedPoints.map(row => row.join("\t")).join("\n");
            textareaForce.value = predefinedForce.map(row => row.join("\t")).join("\n");
            textareaCoord.value = predefinedCoord.map(row => row.join("\t")).join("\n");
            textareaStiff.value = predefinedStiff.map(row => row.join("\t")).join("\n");

            drawVectors()
            
            
            function drawVectors() {

                const matrixInput1 = document.getElementById("matrix-input1");
                const matrixValue1 = matrixInput1.value;

                const matrixInput2 = document.getElementById("matrix-input2");
                const matrixValue2 = matrixInput2.value;

                const matrixInput3 = document.getElementById("matrix-input3");
                const matrixValue3 = matrixInput3.value;
                //console.log(matrixValue3)
                const matrixInput4 = document.getElementById("matrix-input4");
                const matrixValue4 = matrixInput4.value;

                const matrixInput5 = document.getElementById("matrix-input5");
                const matrixValue5 = matrixInput5.value;

                // Convert the matrix values to arrays
                const matrixArray1 = matrixValue1.trim().split(/\s*\n\s*/).map(row => row.trim().split(/\s+/).map(Number));
                const matrixArray2 = matrixValue2.trim().split(/\s*\n\s*/).map(row => row.trim().split(/\s+/).map(Number));
                const matrixArray3 = matrixValue3.trim().split(/\s*\n\s*/).map(row => row.trim().split(/\s+/).map(Number));
                const matrixArray4 = matrixValue4.trim().split(/\s*\n\s*/).map(row => row.trim().split(/\s+/).map(Number));
                const matrixArray5 = matrixValue5.trim().split(/\s*\n\s*/).map(row => row.trim().split(/\s+/).map(Number));

                //const matrixArray5 = matrixValue5.trim().split(/\s+/).map(Number);

                // Check that the matrix arrays have the correct dimensions and contain only numbers
                const isMatrixValid1 = matrixArray1.length === 6 && matrixArray1.every(row => row.length === 3 && row.every(val => !isNaN(val)));
            const isMatrixValid2 = matrixArray2.length === 6 && matrixArray2.every(row => row.length === 3 && row.every(val => !isNaN(val)));
            const isMatrixValid3 = matrixArray3.every(row => row.length === 3 && row.every(val => !isNaN(val)));
            const isMatrixValid4 = matrixArray4.every(row => row.length === 3 && row.every(val => !isNaN(val)));

                //const isMatrixValid5 = matrixArray4.length === 1 && matrixArray5.every(val => !isNaN(val));


                //create3DPlot(matrixArray1, matrixArray2, matrixArray3, matrixArray4)
                //console.log(math.multiply(normr(matrixArray3),boundingBoxSize.maxDimension*0.2))



                A = ForceA(matrixArray2, normr(matrixArray1))
                B = rowForceB(matrixArray3, matrixArray4)
                //console.log(math.multiply(math.inv(A), B))

                const ForceIf = math.multiply(math.inv(A), B)
                def = dotMult(ForceIf, reciprocalArray(matrixArray5))

                mMat = math.multiply(motionAinv(normr(matrixArray1), matrixArray2), def)

                //console.log(def)

                result = combineArrays(ForceIf, def)
                //console.log(result)



                document.getElementById("ForcesOnIf").innerHTML = ForceIf;
                rowNames = ['n1', 'n2', 'n3', 'n4', 'n5', 'n6'];
                columnNames = ["Forces"];
                populateTable("ForcesOnIf", roundArrayToDecimals(ForceIf, 4), "12px", "fixed", rowNames, columnNames, "forces on interfaces")

                document.getElementById("DefOffIf").innerHTML = def;
                rowNames = ['n1', 'n2', 'n3', 'n4', 'n5', 'n6'];
                columnNames = ["Forces"];
                populateTable("DefOffIf", def, "12px", "exponential", rowNames, columnNames, "deformation interfaces")

                document.getElementById("DefOffWCS").innerHTML = mMat;
                rowNames = ['X', 'Y', 'Z', 'Rx', 'Ry', 'Rz'];
                columnNames = ["Forces"];
                populateTable("DefOffWCS", mMat, "12px", "exponential", rowNames, columnNames, "body deformation WCS")

                calculateBoundingBoxSize(matrixValue2)
                const boundingBoxSize = calculateBoundingBoxSize(predefinedPoints);
                normr(matrixArray3)
                create3DPlot(normr(matrixArray1), matrixArray2, math.multiply(normr(matrixArray3), boundingBoxSize.maxDimension * 0.5), matrixArray4)




            }



        </script>

</main>
<footer>
    <p>&copy Code by Sander Struycken &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E-mail: sander.struycken@asml.com</p>
</footer>


</html>